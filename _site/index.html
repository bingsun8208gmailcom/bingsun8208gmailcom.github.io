<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Falcon's Blogs</title>
	
	<meta name="author" content="Falcon">

	<!-- Enable responsive viewport -->
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
	<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<!-- Le styles -->
	<link href="/assets/resources/bootstrap/css/bootstrap.min.css" rel="stylesheet">
	<link href="/assets/resources/font-awesome/css/font-awesome.min.css" rel="stylesheet">
	<link href="/assets/resources/syntax/syntax.css" rel="stylesheet">
	<link href="/assets/css/style.css" rel="stylesheet">
	<link href="/assets/css/highlight/vs.css" rel="stylesheet">
	<script type="text/javascript" src="/assets/js/jquery-1.7.2.js"></script>
	<script type="text/javascript" src="/assets/js/highlight.pack.js"></script>
	<!-- Le fav and touch icons -->
	<!-- Update these with your own images
	<link rel="shortcut icon" href="images/favicon.ico">
	<link rel="apple-touch-icon" href="images/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
	-->

	<link rel="alternate" type="application/rss+xml" title="" href="/feed.xml">
	<script type="text/javascript">
		$(document).ready(function() {
			$('pre code').each(function(i, block) {
				hljs.highlightBlock(block);
			});
		});
	</script>
</head>

<body>
	<nav class="navbar navbar-default visible-xs" role="navigation">
		<!-- Brand and toggle get grouped for better mobile display -->
		<div class="navbar-header">
			<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			
			<a type="button" class="navbar-toggle nav-link" href="http://github.com/bingsun8208gmailcom">
				<i class="fa fa-github"></i>
			</a>
			
			
			
			<a type="button" class="navbar-toggle nav-link" href="mailto:bingsun8208@hotmail.com">
				<i class="fa fa-envelope"></i>
			</a>
			
			<a class="navbar-brand" href="/">
				<img src="/assets/media/baobao.jpg" class="img-circle" />
				
			</a>
		</div>

		<!-- Collect the nav links, forms, and other content for toggling -->
		<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
			<ul class="nav navbar-nav">
				<li class="active"><a href="/">Home</a></li>
				<li><a href="/categories.html">Categories</a></li>
				<li><a href="/tags.html">Tags</a></li>
			</ul>
		</div><!-- /.navbar-collapse -->
	</nav>

	<!-- nav-menu-dropdown -->
	<div class="btn-group hidden-xs" id="nav-menu">
		<button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown">
			<i class="fa fa-bars"></i>
		</button>
		<ul class="dropdown-menu" role="menu">
			<li><a href="/"><i class="fa fa-home"></i>Home</a></li>
			<li><a href="/categories.html"><i class="fa fa-folder"></i>Categories</a></li>
			<li><a href="/tags.html"><i class="fa fa-tags"></i>Tags</a></li>
			<li class="divider"></li>
			<li><a href="#"><i class="fa fa-arrow-up"></i>Top of Page</a></li>
		</ul>
	</div>

	<div class="col-sm-3 sidebar hidden-xs">
		<! -- sidebar.html -->
<header class="sidebar-header" role="banner">
	<a href="/">
		<img src="/assets/media/baobao.jpg" class="img-circle" style="width: 160px; height: 160px;" />
	</a>
	<h3 class="title">
        <a href="/"></a>
    </h3>
</header>


<div id="bio" class="text-center">
	茶隼的自言自语
</div>


<div id="contact-list" class="text-center">
	<ul class="list-unstyled list-inline">
		
		<li>
			<a class="btn btn-default btn-sm" href="https://github.com/bingsun8208gmailcom">
				<i class="fa fa-github-alt fa-lg"></i>
			</a>
		</li>
		
		
		
		<li>
			<a class="btn btn-default btn-sm" href="mailto:bingsun8208@hotmail.com">
				<i class="fa fa-envelope fa-lg"></i>
			</a>
		</li>
		
	</ul>
	<ul id="contact-list-secondary" class="list-unstyled list-inline">
		
		
		<li>
			<a class="btn btn-default btn-sm" href="/feed.xml">
				<i class="fa fa-rss fa-lg"></i>
			</a>
		</li>
	</ul>
</div>
<! -- sidebar.html end -->

	</div>

	<div class="col-sm-9 col-sm-offset-3">
		<div class="page-header">
  <h1>Falcon's Blogs </h1>
</div>



<article class="home">

  <span class="post-date">
    
    February
    19th,
    
    2016
  </span>

  <h2>
    <a href="/it/2016/02/19/golang-study.html">Go语言入门</a>
  </h2>

  <div>
    
    <h1 id="go">GO语言介绍</h1>

<p>Go语言是谷歌2009发布的第二款开源编程语言。
Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。</p>

<h1 id="section">安装</h1>

<p>Go语言官网为<a href="http://www.golang.org">www.golang.org</a>，不过由于网络原因（你懂的），我们无法正常访问，不过好在国内有众多Go语言爱好者，因此可以在墙内下载<a href="http://www.golangtc.com">www.golangtc.com</a>。
根据不同平台，下载对应版本。安装完成后，配置GOROOT和GOPATH，注意，GOROOT为Go语言安装路径。如：</p>

<pre><code>windows:      c:\go
linux:        /usr/local/go
</code></pre>

<p>GOPATH为Go源码所在路径。注意GOROOT和GOPATH的路径一定不能相同。</p>

<h1 id="hello-world">Hello World</h1>

<pre><code>package main

import "fmt"

func main() {
    fmt.Println("Hello World")
}
</code></pre>

<p>每个Go源文件开头都有一个package声明语句，指明源文件所在的包。同时，我们也可以根据具体的需要 来选择导入(import语句)特定功能的包。在这个例子中，我们通过导入fmt包来使用我们熟悉的printf函数。 不过在Go语言中，Printf函数的是大写字母开头，并且以fmt包名作为前缀：fmt.Printf。</p>

<p>关键字func用于定义函数。在所有初始化完成后，程序从main包中的main函数开始执行。</p>

<p>常量字符串可以包含Unicode字符，采用UTF-8编码。实际上，所有的Go语言源文件都采用UTF-8编码。</p>

<p>代码注释的方式和C++类似：</p>

<pre><code>      /* ... */
      // ... 稍后，我们还有很多的关于打印的话题。
</code></pre>

<h1 id="section-1">编译</h1>
<p>打开终端，定位到源码所在目录，运行以下命令</p>

<pre><code>go build helloworld.go
go run helloworld.go
helloworld
</code></pre>

<p>结果为：</p>

<pre><code>Hello World
</code></pre>

    
  </div>

</article>


<article class="home">

  <span class="post-date">
    
    January
    10th,
    
    2015
  </span>

  <h2>
    <a href="/it/objective-c/2015/01/10/objective-c-start.html">Objective-C 语法简介</a>
  </h2>

  <div>
    
    <h1 id="section">概述</h1>

<p>Objective-C，通常写作ObjC和较少用的Objective C或Obj-C，是扩充C的面向对象编程语言。它主要使用于Mac OS X和GNUstep这两个使用OpenStep标准的系统，而在NeXTSTEP和OpenStep中它更是基本语言。</p>

<h1 id="section-1">简明概述</h1>

<ul>
  <li>开始学习前，假设你已经具备了一些C语言的基础知识，包括变量类型、函数、返回值、以及指针的相关概念。</li>
  <li>Objective-C，是 C 的衍生体，继承了所有 C 语言的特性。是有一些例外，但是它们不是继承于 C 的语言特性本身。</li>
  <li>nil：在 C/C++ 你或许曾使用过 NULL，而在 Objective-C 中则是 nil。不同之处是你可以传递消息给 nil（例如 [nil message];），这是完全合法的，然而你却不能对 NULL 如法炮制，由于nil是一个Objective-C类对象的引用类型（即id类型），而NULL在C语言中通常被定义为(void*)0，因而并不是一个Objective-C类对象的引用。</li>
  <li>BOOL：C没有正式的布尔类型，而在 Objective-C 中也不是「真的」有。它是包含在 Foundation classes（基本类别库）中（即 import NSObject.h；nil 也是包括在这个标头档内）。BOOL 在 Objective-C 中有两种型态：YES 或 NO，而不是 TRUE 或 FALSE。</li>
  <li>#import vs #include：就如同你在 hello world 范例中看到的，我们使用了 #import。#import 由 gcc 编译器支援。我并不建议使用 #include，#import 基本上跟 .h 档头尾的 #ifndef #define #endif 相同。许多程式员们都同意，使用这些东西这是十分愚蠢的。无论如何，使用 #import 就对了。</li>
</ul>

<h1 id="hello-world">Hello World</h1>

<h2 id="hellom">hello.m</h2>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

int main( int argc, const char *argv[] ) {
	NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
	NSLog( @"hello world" );
	[pool drain];
	return 0;
}
</code></pre>

<h2 id="section-2">输出</h2>

<pre><code>hello world
</code></pre>

<ul>
  <li>在Objective-C中使用 #import 代替 #include</li>
  <li>Objective-C的代码文件使用.m后缀</li>
  <li>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; 代表程序将在缓存池里预留内存空间， [pool drain]; 表示释放内存空间。</li>
  <li>NSLog具有自动换行功能，因此不需要\n</li>
</ul>

<h1 id="section-3">类</h1>

<h2 id="section-4">示例</h2>

<h3 id="fractionh">Fraction.h</h3>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
@interface Fraction : NSObject {
	int numerator;
	int denominator;
}

- (void) print;
- (void) setNumberator : (int) n;
- (void) setDenominator : (int) d;
- (int) numerator;
- (int) denominator;

@end
</code></pre>

<h3 id="fractionm">Fraction.m</h3>

<pre><code>#import "Fraction.h"

@implementation Fraction 

- (void) print {
	NSLog(@"%i/%i", numerator, denominator);
}

- (void) setNumberator : (int) n {
	numerator = n;
}
- (void) setDenominator : (int) d {
	denominator = d;
}
- (int) numerator {
	return numerator;
}
- (int) denominator {
	return denominator;
}

@end
</code></pre>

<ul>
  <li>NSObject是Objective-C中所有类的基类，它位于类继承链的最顶端，等同于C#中的Object。</li>
  <li>夹在 @interface Fraction : NSObject { … } 中的被称为实例变量(instance variables)。</li>
  <li>没有设定存取权限（protected, private, public)时，默认权限为 protected 。</li>
  <li>instance methods 以 - 开头（等同于C#的成员函数），class level methods 以 + 开头（等同于C#的static静态函数）。</li>
  <li>类(@interface)以 @end 作为结束符。</li>
  <li>在.m文件中，使用@implementation修饰符来实现.h文件中定义的类。</li>
</ul>

<h2 id="section-5">合成存储器方法</h2>

<p>前例中，Fraction类中numerator,denominator分别手工设置了getter和setter，</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
@interface Fraction : NSObject {
	int numerator;
	int denominator;
}

- (void) print;
- (void) setNumberator : (int) n;
- (void) setDenominator : (int) d;
- (int) numerator;
- (int) denominator;

@end
</code></pre>

<p>考虑改进方法，</p>

<pre><code>// Fraction.h
#import &lt;Foundation/Foundation.h&gt;
@interface Fraction : NSObject {
	int numerator;
	int denominator;
}

@property int numerator, denominator;
- (void) print;

@end

// Fraction.m

@implementation Fraction

@synthesize numerator, denominator;

- (void) print {
	NSLog(@"%i/%i", numerator, denominator);
}

@end
</code></pre>

<p>其中@property int numerator, denominator;是为类Fraction定义两个实例变量numerator, denominator；
@synthesize则是告诉编译器要为numerator, denominator自动生成getter，setter方法。</p>

    
  </div>

</article>


<article class="home">

  <span class="post-date">
    
    December
    19th,
    
    2014
  </span>

  <h2>
    <a href="/it/csharp/2014/12/19/linq-groupby.html">Linq中GroupBy的应用</a>
  </h2>

  <div>
    
    <h1 id="group">Group</h1>
<p>Group是进行分组操作，同SQL中的Group By类似。
接口原型：</p>

<pre><code>public static IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector);

public static IEnumerable&lt;TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, Func&lt;TKey, IEnumerable&lt;TSource&gt;, TResult&gt; resultSelector);

public static IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, Func&lt;TSource, TElement&gt; elementSelector);

public static IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, IEqualityComparer&lt;TKey&gt; comparer);

public static IEnumerable&lt;TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, Func&lt;TKey, IEnumerable&lt;TSource&gt;, TResult&gt; resultSelector, IEqualityComparer&lt;TKey&gt; comparer);

public static IEnumerable&lt;TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, Func&lt;TSource, TElement&gt; elementSelector, Func&lt;TKey, IEnumerable&lt;TElement&gt;, TResult&gt; resultSelector);

public static IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, Func&lt;TSource, TElement&gt; elementSelector, IEqualityComparer&lt;TKey&gt; comparer);

public static IEnumerable&lt;TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, Func&lt;TSource, TElement&gt; elementSelector, Func&lt;TKey, IEnumerable&lt;TElement&gt;, TResult&gt; resultSelector, IEqualityComparer&lt;TKey&gt; comparer);
</code></pre>

<p>接口重载返回两种类型 IEnumerable<tresult> 和 IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;
示例：</tresult></p>

<pre><code>// 1. Lambda表达式方式
var result = from score in DataSource.Scores 
         group score by score.StudentID into scoreGroup 
         select scoreGroup;

// 2. 链式表达式方式
var result = ScoreList.GroupBy(s =&gt; s.StudentID, s =&gt; s);
</code></pre>

<p>其中scoreGroup为IGrouping&lt;TKey, TSource&gt;类型，返回结果为IEnumerable&lt;IGrouping&lt;TKey, TSource»
IGrouping&lt;TKey, TSource»接口原型：</p>

<pre><code>public interface IGrouping&lt;out TKey, out TElement&gt; : IEnumerable&lt;TElement&gt;, IEnumerable
{
    TKey Key { get; }
}
</code></pre>

<p>其中Key为分组依据的字段</p>

<pre><code>foreach (var score in result)
{
	var studentID = score.Key;
	var list = score.ToList();
}
</code></pre>


    
  </div>

</article>


<article class="home">

  <span class="post-date">
    
    December
    5th,
    
    2014
  </span>

  <h2>
    <a href="/it/python/2014/12/05/python-errors.html">Python异常处理</a>
  </h2>

  <div>
    
    <p>一个典型的Python错误处理语句：</p>

<pre><code>#!/usr/bin/python

import traceback
try:
    1/0
except Exception as e:
    print e
</code></pre>

<h1 id="try">一：try语句</h1>

<h2 id="tryexcept">1 使用try和except语句来捕获异常</h2>

<pre><code>try:
    block
except [exception,[data…]]:
    block

try:
    block
except [exception,[data...]]:
    block
else:
    block
</code></pre>

<p>该种异常处理语法的规则是：</p>

<p>·   执行try下的语句，如果引发异常，则执行过程会跳到第一个except语句。</p>

<p>·   如果第一个except中定义的异常与引发的异常匹配，则执行该except中的语句。</p>

<p>·   如果引发的异常不匹配第一个except，则会搜索第二个except，允许编写的except数量没有限制。</p>

<p>·   如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。</p>

<p>·   如果没有发生异常，则执行else块代码。</p>

<p>例:</p>

<pre><code>try:
    f = open(“file.txt”,”r”)
except IOError, e:
    print e
</code></pre>

<p>捕获到的IOError错误的详细原因会被放置在对象e中,然后运行该异常的except代码块</p>

<p>捕获所有的异常</p>

<pre><code>try:
    a=b
    b=c
except Exception,ex:
    print Exception,":",ex
</code></pre>

<p>使用except子句需要注意的事情，就是多个except子句截获异常时，如果各个异常类之间具有继承关系，则子类应该写在前面，否则父类将会直接截获子类异常。放在后面的子类异常也就不会执行到了。</p>

<h2 id="tryfinally">2 使用try跟finally:</h2>

<p>语法如下:</p>

<pre><code>try:
    block
finally:
    block
</code></pre>

<p>该语句的执行规则是：</p>

<p>·   执行try下的代码。</p>

<p>·   如果发生异常，在该异常传递到下一级try时，执行finally中的代码。</p>

<p>·   如果没有发生异常，则执行finally中的代码。</p>

<p>第二种try语法在无论有没有发生异常都要执行代码的情况下是很有用的。例如我们在python中打开一个文件进行读写操作，我在操作过程中不管是否出现异常，最终都是要把该文件关闭的。</p>

<p>这两种形式相互冲突，使用了一种就不允许使用另一种，而功能又各异</p>

<h1 id="raise">二：用raise语句手工引发一个异常</h1>

<pre><code>raise [exception[,data]]
</code></pre>

<p>在Python中，要想引发异常，最简单的形式就是输入关键字raise，后跟要引发的异常的名称。异常名称标识出具体的类：Python异常是那些类的对象。执行raise语句时，Python会创建指定的异常类的一个对象。raise语句还可指定对异常对象进行初始化的参数。为此，请在异常类的名称后添加一个逗号以及指定的参数（或者由参数构成的一个元组）。</p>

<p>例:</p>

<pre><code>try:
    raise MyError #自己抛出一个异常
except MyError:
    print 'a error'

raise ValueError,’invalid argument’
</code></pre>

<p>捕捉到的内容为:</p>

<pre><code>type = VauleError
message = invalid argument
</code></pre>

<h1 id="traceback">三：采用traceback(跟踪)模块查看异常</h1>

<p>发生异常时，Python能“记住”引发的异常以及程序的当前状态。Python还维护着traceback（跟踪）对象，其中含有异常发生时与函数调用堆栈有关的信息。记住，异常可能在一系列嵌套较深的函数调用中引发。程序调用每个函数时，Python会在“函数调用堆栈”的起始处插入函数名。一旦异常被引发，Python会搜索一个相应的异常处理程序。如果当前函数中没有异常处理程序，当前函数会终止执行，Python会搜索当前函数的调用函数，并以此类推，直到发现匹配的异常处理程序，或者Python抵达主程序为止。这一查找合适的异常处理程序的过程就称为“堆栈辗转开解”（Stack Unwinding）。解释器一方面维护着与放置堆栈中的函数有关的信息，另一方面也维护着与已从堆栈中“辗转开解”的函数有关的信息。</p>

<p>格式:</p>

<pre><code>try:
    block
except:
    traceback.print_exc()
</code></pre>


    
  </div>

</article>


<article class="home">

  <span class="post-date">
    
    December
    2nd,
    
    2014
  </span>

  <h2>
    <a href="/it/db/2014/12/02/postgresql-psql.html">PostgreSQL 命令行 psql</a>
  </h2>

  <div>
    
    <h1 id="psql">psql</h1>

<h2 id="section">语法</h2>

<pre><code>psql [参数]

dbname	# 声明将要抽取的数据库名．dbname 缺省为 USER 环境变量的值．
-a # 从脚本中响应所有输入
-A # 取消表数据输出的对齐模式；功能与“-P format=unaligned”相同
-c &lt;查询&gt; # 仅仅运行一个简单的查询（或者内部命令）然后退出
-d # 指定连接到的数据库名（默认为$PGDATABASE或者当前登录用户名）
-e # 回显发送到服务器的查询
-E # 显示内部命令生成的查询语句
-f &lt;文件名&gt; # 执行一个文件中的查询，然后退出
-F &lt;字符串&gt; # 指定列数据显示分隔符（默认为“|”）；功能与“-P fieldsep=&lt;字符串&gt;”相同
-h # 指定数据库服务器主机（默认为$PGHOST或者本地主机）
-H # 设置表格输出模式为HTML；功能与“-P format=html”相同
-l # 列出存在的数据库，然后退出
-n # 禁用readline；阻止行编辑
-o &lt;文件名&gt; # 将查询的输出发送到文件名指定文件（使用“|管道”的形式将输出发送到一个过滤程序）
-p # 指定数据库服务器的端口（默认为$PGPORT或者编译期设置的默认值，通常为5432）
-P var[=arg] # 设置打印选项var为arg（查看\pset命令）
-q # 以静默方式运行（没有任何消息，仅有查询的输出）
-R &lt;字符串&gt; # 设置记录的分隔符（默认为换行）；功能与“-P recordsep=&lt;字符串&gt;”相同
-s # 设置为单步执行模式（每条查询都需要确认）
-S # 设置单行模式（每行结束就认为查询输入结束，而不是分号）
-t # 只打印行；功能与“-P tuples_only”相同
-T &lt;文本&gt; # 设置HTML表格标记选项（width，border等）；功能与“-P tableattr=&lt;text&gt;”相同
-v name=value # 设置psql变量name的值为value
--version # 显示版本信息然后退出，也可以用“-V”
-U # 声明 postmaster 在运行的机器的数据库用户名
-W # 强制提示输入密码（如果需要密码，会自动执行）
-x # 开启扩展表格输出；功能与“-P expanded”相同
-X # 不读取启动文件（~/.psqlrc）
</code></pre>

<h2 id="section-1">描述</h2>

<p>psql 是一个以终端为基础的 PostgreSQL 前端。它允许你交互地键入查询，把它们发出给 PostgreSQL， 然后看看查询的结果。另外，输入可以来自一个文件。还有， 它提供了一些元命令和多种类 shell 地特性来实现书写脚本以及对大量任务的自动化。</p>

<h2 id="section-2">退出状态</h2>

<p>如果正常结束，那么 psql 向 shell 返回 0， 如果自身发生致命错误，则返回 1（内存用尽，未找到文件等）， 如果和数据库的连接失效而且会话不再活跃则返回 2， 如果脚本中发生错误并且设置了 ON_ERROR_STOP 则返回 3。</p>

<h2 id="section-3">用法</h2>

<h3 id="section-4">与一个数据库联接</h3>

<p>psql 是一个普通的 PostgreSQL 客户端应用。为了与一个数据库联接，你需要知道你的目标数据库， 服务器的主机名和端口号以及你希望以哪个用户的身份进行联接等信息。 我们可以通过命令行参数告诉 psql 这些信息，分别是 -d， -h，-p，和 -U。 如果有个参数不属于任何选项开关， 那么它会被解释成数据库名（或者是用户名——如果数据库名称已经给出了。）。 不是所有这些选项都是必须的，有缺省存在。 如果你省略主机名， psql 将通过 Unix 域套接字与本地主机的服务器相联， 或者在没有 unix 域套接字的机器上，通过 TCP/IP 与 localhost 连接。 缺省的端口号是编译时确定的。因为数据库服务器使用同样的缺省值， 所以在大多数设置下，你可能不需要声明端口号。缺省的用户名是你的 Unix 用户名，与数据库同名。 要注意的是你不能用任意用户名与任何数据库相联。你的数据库管理员应该告诉你你的访问权限。</p>

<p>如果缺省不太正确，那么你可以通过设置几个环境变量 PGDATABASE， PGHOST，PGPORT 和/或 PGUSER 为对应的值的方法节约几次敲击。 （其它的环境变量的信息，参阅 Section 28.11。） 另外，用一个 ~/.pgpass 文件来避免输入密码也是很方便的。 参阅 Section 28.12 获取更多信息。</p>

<p>如果因为任何原因而无法与数据库相联（例如，权限不够，服务器没有运行等）， psql 将返回一个错误并退出。</p>

<h3 id="sql">输入SQL命令</h3>

<p>通常状况下，psql 提供一个带有 psql 正在与之联接的接数据库名的，后缀 =&gt;的提示符。例如，</p>

<pre><code>$ psql testdb
Welcome to psql 8.1, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
	   \h for help with SQL commands
	   \? for help with psql commands
	   \g or terminate with semicolon to execute query
	   \q to quit

testdb=&gt;
</code></pre>

<p>用户可以在这个提示符下键入SQL 查询。 通常，输入的行将在命令终止分号出现时送到服务器。 一行的终止并不结束命令！因此命令可以因清晰起见跨越好几行。如果命令发送出去而且执行没有错误， 命令结果会显示在屏幕上。</p>

<p>当命令正在进行时，psql 同样还轮询由 LISTEN 和 NOTIFY. 生成的异步通知信号。</p>

<h2 id="section-5">高级特性</h2>

<h3 id="section-6">变量</h3>

<p>psql 提供类似通常 Unix 命令 shell 那样的变量替换特性。 变量只是简单的名称/数值对， 这里的值可以是任何长度的任何值。要设置一个变量，使用 psql 元命令 \set：</p>

<pre><code>testdb=&gt; \set foo bar
</code></pre>

<p>把变量”foo” 设置为值 “bar”。 要检索变量的内容，在变量名前面放上冒号然后把它用在任意斜杠命令里：</p>

<pre><code>testdb=&gt; \echo :foo
bar
</code></pre>

<p><strong>注意:</strong> \set 的参数服从和其他命令一样的替换规则。 因此你可以构造有趣的引用，象 \set :foo ‘something’ 这样， 获得分别象Perl或 PHP那样有名的”软连接（soft links）”或”变量 变量”。 不幸的是（或者 万幸的？），用这些构造不能做任何有用的事情。另一方面， \set bar :foo 是一个非常有效的拷贝变量的方法。</p>

<p>如果你不带第二个参数调用\set， 那么只是设置这个变量而没有值。 要重置（或删除）一个变量，使用命令 \unset。</p>

<p>psql的内部变量可以包括任意顺序， 任意数量的字母，数字和下划线。 有一些常用变量被 psql 另眼相待。它们是一些选项设置， 这些选项在运行时可以通过改变变量的值或者改变一些应用的表现状态而改变。 尽管你可以把这些变量用于其他用途，但是我们不鼓励这么做，因为程序的特性可能会很快变得非常奇怪。 通常，所有特殊对待的变量都是由大写字母组成（可能还有数字和下划线）。 为了保证和未来的最大限度的兼容性，请避免使用这样的变量。 下面是一个所有特殊对待的变量列表。</p>

<p>AUTOCOMMIT
如果是 on（缺省），那么每个 SQL 命令都在成功完成后自动提交。 要推迟这种模式下的提交，你必须输入一个 BEGIN 或者 START TRANSACTION SQL 命令。 如果是 off 或者未设置，SQL 命令不会提交，知道你明确地发出 COMMIT 或者 END。 关闭自动提交的模式是通过为你明确发出一个 BEGIN 实现的， 它是放在任何尚未在一个事务块中并且自己不是 BEGIN 或者其它事务控制命令也不是那些不能在事务块里执行的命令 （比如 VACUUM）的前面。</p>

<p><strong>注意:</strong> 在关闭自动提交的模式下，你必须明确放弃任何失败的事务，方法是执行 ABORT 或者 ROLLBACK。 还要注意如果你不提交就退出会话，你的工作会丢失。</p>

<p><strong>注意:</strong> 自动提交打开方式是 PostgreSQL 传统的行为， 但是关闭自动提交更接近 SQL 规范。如果你喜欢关闭自动提交，你应该在你的 .psqlrc 文件里设置它。</p>

<p>DBNAME
你正在联接着的数据库名称。 每次你与一个数据库联结都会设置这个值（包括程序启动），但是可以删除。</p>

<p>ECHO
如果置为 all， 输入的或者来自键盘或者一个脚本的所有行在分析或执行前都写到标准输出。 要在程序启动时声明这些，使用 -a如果设置为 queries， psql 只是在查询发送给服务器之前打印出来。 实现这个功能的命令行选项是 -e。</p>

<p>ECHO_HIDDEN
当设置了这个变量并且一个反斜杠命令查询数据库时，首先显示查询。 这样你可以学习 PostgreSQL 内部的东西并且在你自己的程序里提供类似功能。如果你设置该变量的值为 “noexec”，查询只是显示出来但是实际上不发送到服务器和执行。</p>

<p>ENCODING
当前的客户端字符集编码。</p>

<p>HISTCONTROL
如果这个变量设置为 ignorespace， 以空格开始的行将不会进入历史列表。 如果设置为变量 ignoredups， 与以前历史记录里匹配的行也不会进入历史记录。值 ignoreboth是上面两个的结合。 如果删除此变量或者其值为任何与上面的值不同的东西， 所有交互模式读入的行都被保存入历史列表。</p>

<p><strong>注意:</strong> 这个特性是无耻地从 Bash 里剽窃来的。</p>

<p>HISTFILE
此文件将用于存储历史列表。缺省值是 ~/.psql_history。 比如，在 ~/.psqlrc 里使用：</p>

<p>\set HISTFILE ~/.psql_history- :DBNAME
将令 psql 为每个数据库维护一个独立的历史。</p>

<p><strong>注意:</strong> 这个特性是从 Bash 里偷学来的。</p>

<p>HISTSIZE
存在命令历史里的命令的个数。缺省值是 500。</p>

<p><strong>注意:</strong> 这个特性是无耻地从 Bash里剽窃来的。</p>

<p>HOST
当前你正联接的数据库服务器主机。 这是在每次你与数据库联接时（包括程序启动）设置的，但是可以删除。</p>

<p>IGNOREEOF
如果删除此变量，向一个交互的 psql会话发送一个 EOF （通常是 Control-D）将终止应用。如果设置为一个数字值，那么在应用终止前该数值的 EOF 字符将被忽略。 如果设置了此变量但是没有数字值，缺省是 10。</p>

<p><strong>注意:</strong> 这个特性是无耻地从 Bash 里剽窃来的。</p>

<p>LASTOID
最后影响的oid值，即为从一条 INSERT 或 lo_insert 命令返回的值。 此变量只保证在下一条 SQL 命令的结果显示之前有效。</p>

<p>ON_ERROR_ROLLBACK
如果是 on，如果一个事务块里的语句产生一个错误， 那么这个错误被忽略而事务讲继续。如果是 interactive， 那么这样的错误只是在交互的会话里忽略，而不是在从读取脚本文件的时候。 如果是 off（缺省），事务块里一个语句生成的错误将会回滚整个事务。 on_error_rollback-on 的模式是通过在一个事务块的每个命令前为你隐含地发出一个 SAVEPONT 的方式工作的，在发生错误的时候回滚到该事务块。</p>

<p>ON_ERROR_STOP
缺省时，如果非交互的脚本碰到一个错误，象一条错误的 SQL 命令或者内部元命令，处理会继续进行。 这是 psql 的传统特性， 但是有时候我们不太希望这样。如果设置了这个变量，脚本处理将马上停止。 如果该脚本是从另外一个脚本调用的，那个脚本也会按同样的方式停止。 如果最外层的脚本不是从一次交互的 psql 会话中调用的而是用 -f 选项调用的，psql 将返回错误代码 3，以示这个情况与致命错误条件的区别（错误代码 1）。</p>

<p>PORT
当前你正在联接的数据库服务器的端口。 这是在每次你与数据库联接时（包括程序启动）设置的，但是可以删除。</p>

<p>PROMPT1
PROMPT2
PROMPT3
这些指明psql 显示的提示符看上去象什么。 参阅下面的 提示符。</p>

<p>QUIET
这个变量等效于命令行选项 -q。 可能在交互模式下没有什么用。</p>

<p>SINGLELINE
这个变量等效于设置命令行选项 -S。你可以在运行时删除或设置它。</p>

<p>SINGLESTEP
这个变量等效于命令行选项 -s。</p>

<p>USER
当前你正用于联接的数据库用户。 这是在每次你与数据库联接时（包括程序启动）设置的，但是可以删除/重置。</p>

<p>VERBOSITY
这个选项可以设置为值 default，verbose，或者 terse 以控制错误报告的冗余行。</p>

<h3 id="sql-1">SQL代换</h3>

<p>一个附加的 psql 变量的有用特性是你可以把它们替换（”代换”）成正规的 SQL 语句。这样做的语法同样还是变量名前面加一个冒号（:）。</p>

<pre><code>testdb=&gt; \set foo 'my_table'
testdb=&gt; SELECT * FROM :foo;
</code></pre>

<p>将会查询表my_table。变量的值是逐字拷贝的， 所以它甚至可以包含不对称的引号或反斜杠命令。你必须保证你输入的东西是有意义的。 变量替换将不会在引号引起来的 SQL 语句里面发生。</p>

<p>利用这个功能的一个时髦的应用是通过使用一个随后的语句中最后插入的 OID 建立一个外键仿真场景。 另一个可能用到这个机制的地方是把一个文件的内容拷贝到一个字段里面去。 首先把文件装载到一个变量然后象上面那样处理。</p>

<pre><code>testdb=&gt; \set content '\'' `cat my_file.txt` '\''
testdb=&gt; INSERT INTO my_table VALUES (:content);
</code></pre>

<p>这样处理的一个可能问题是 my_file.txt 可能包含单引号。这些需要被逃逸以免在处理第三行时不会导致语法错误。 可以使用程序 sed来做这个处理：</p>

<pre><code>testdb=&gt; \set content '\'' `sed -e "s/'/\\\\\\'/g" &lt; my_file.txt` '\''
</code></pre>

<p>观察正确数量的反斜杠（6）！你可以这样解释它：在 psql 分析完这行后，它把 sed -e “s/’/\'/g” &lt; my_file.txt 传递给shell。 shell 将对双引号里的东西做其处理然后用参数 -e 和 s/’/\‘/g执行 sed。当 sed分析这些时， 它将把双反斜杠替换为单个反斜杠然后进行替换。 可能有时候你认为所有 Unix 命令使用同一个逃逸字符是个好事。 但具有讽刺意味的事实是你可能不得不逃逸所有反斜杠，因为 SQL 文本常量同样也惨遭这种解释。 这种情况下你可能最好在外部准备文件。</p>

<p>因为冒号也可以合法的出现在 SQL 命令里，便有下面规则的应用： 如果没有设置变量，字符序列 “冒号+名称” 不会被改变。 在任何情况下你都可以用反斜杠逃逸冒号以保护它免于被解释。 （变量的冒号语法是 SQL 用于嵌入查询语言的标准，如 ECPG。用于数组片段和类型转换的冒号语法是 PostgreSQL 扩展，因此有冲突。）</p>

<h2 id="windows-">Windows 用户需要注意的地方</h2>

<p>psql 是以一种”控制台应用”的方式制作的。 因为 Windows 控制台窗口和系统其它部分使用不同的编码， 所以在 psql 里使用 8 位字符的时候必须采取特殊的注意措施。 如果 psql 检测到一个有问题的控制台代码页， 那么它在启动的时候会警告你。要修改控制台代码页，有两件事是必须做的：</p>

<p>通过输入 cmd.exe /c chcp 1252 设置代码页。（1252 是适用于德语的代码页；换成合适你的数值。译注：中文 GB2312 的代码页是 936。） 如果你使用 Cygwin，你可以在 /etc/profile 里面输入这条命令。</p>

<p>把控制台字体设置为 “Lucida Console”，因为光栅字体（点阵字体）不能在 ANSI 代码页下工作。</p>

    
  </div>

</article>


<article class="home">

  <span class="post-date">
    
    December
    1st,
    
    2014
  </span>

  <h2>
    <a href="/it/db/2014/12/01/postgresql-pg_dump.html">PostgreSQL 命令行pg_dump</a>
  </h2>

  <div>
    
    <h1 id="pgdump">pg_dump</h1>

<h2 id="section">语法</h2>

<pre><code>pg_dump [参数]

dbname	# 声明将要抽取的数据库名．dbname 缺省为 USER 环境变量的值．
-a # 只输出数据，不输出结构（表定义）．
-c # 创建前删除表定义。
-d # 将数据输出为合适的插入字串．
-D # 将数据作为带字段名的插入语句输出．
-i # 忽略在  pg_dump 和数据库服务器之间的版本差别．因为 pg_dump知道许多关于系统表的信息，任何给定版本的 pg_dump只能和对应的数据库服务器版本一并使用．如果你需要跨越版本检查时才使用这个选项（而且如果 pg_dump 失效，别说我没警告你）．
-n # 除非绝对必需，禁止标识周围的双引号．如果有保留字用于标识符，这么做有可能在装载输出的数据时导致麻烦．这是v6.4以前的 pg_dump 缺省特性。
-N # 在标识周围包括双引号。这是缺省。
-o # 为每个表都输出对象标识（OID）．
-s # 只输出表结构（定义），不输出数据．
-t # 只输出表 table 的数据．
-u # 使用口令认证．提示输入用户名和口令．
-v # 声明冗余模式
-x # 避免输出 ACL（赋予/撤消 命令）和表的所有者关系信息．
-h # 声明 postmaster 在运行的机器的主机名．缺省是使用本地Unix主控套接字，而不是一个IP 联接．
-p # 声明 postmaster 正在侦听并等待联接的TCP/IP端口或本地 Unix 主控套接字文件句柄．缺省的端口号是5432，或者环境变量 PGPORT的值（如果存在）．
-U # 声明 postmaster 在运行的机器的数据库用户名
</code></pre>

<h2 id="section-1">描述</h2>

<p>pg_dump 是一个将 Postgres数据库输出到一个包含查询命令的脚本文件的工具．脚本文件是文本格式并且可以用于重建数据库，甚至可以在其他机器或其他硬件体系上．pg_dump将输出用于重建所有用户定义的类型，函数，表，索引聚集和操作符所必须的查询语句．另外，所有数据是用文本格式拷贝出来的，因而也可以很容易地拷贝回去，也很容易用工具编辑．
pg_dump 在从 Postgres节点向另一个节点一个转移数据时很有用．在运行pg_dump后，我们应该检查输出脚本中的任何警告，尤其是下面列出的限制．</p>

<h2 id="section-2">注意</h2>

<p>pg_dump 有一些限制．限制主要源于从系统表中抽取某些专有信息的困难性．
pg_dump 不能理解部分索引．原因与上面所述相同；部分索引谓词都作为规划存储．（predicates are stored as plans．）
pg_dump 不能处理大对象．大对象被忽略因而必须手工操作．</p>

<p>当只做数据输出时，pg_dump 使用查询在插入数据前关闭用户表上的触发器以及在重新插入数据后恢复．如果重载在途中停止，系统表可能停留在错误的状态．</p>

<h2 id="section-3">用法</h2>

<p>输出与用户名同名的数据库：</p>

<pre><code>pg_dump &gt; db.out
</code></pre>

<p>要重载该数据库：</p>

<pre><code>psql -e database &lt; db.out
</code></pre>

    
  </div>

</article>

<hr/>

<ul class="pager"> 

  
  <li class="previous disabled">
    <a>&larr; Newer</a>
  </li>
  
  
  <li>
    <span class="page_number">Page: 1 of 1</span>
  </li>

  
  <li class="next disabled">
    <a>Older &rarr;</a>        
  </li>
  

</ul>




		<footer>
			<hr/>
			<p>
				&copy; 2016 Falcon with Jekyll. Theme: <a href="https://github.com/dbtek/dbyll">dbyll</a> by dbtek.
			</p>
		</footer>
	</div>

	<script type="text/javascript" src="/assets/resources/jquery/jquery.min.js"></script>
	<script type="text/javascript" src="/assets/resources/bootstrap/js/bootstrap.min.js"></script>
	<script type="text/javascript" src="/assets/js/app.js"></script>
</body>
</html>

